# Node.JS Callback Pattern

Node.js에서 콜백 패턴은 비동기 프로그래밍을 구현하는 방법 중 하나로 사용됩니다. Node.js는 단일 스레드 이벤트 루프 기반의 비동기 I/O 모델을 사용하며, 콜백 패턴을 통해 비동기 작업을 처리합니다.

콜백 패턴은 다음과 같은 구조를 갖습니다

```js
비동기_함수(인자1, 인자2, ..., 콜백_함수);
```

비동기 함수는 비동기적으로 실행되는 작업을 수행하고, 작업이 완료되면 콜백 함수를 호출합니다. 콜백 함수는 비동기 작업이 완료된 후에 실행되는 함수로, 결과를 처리하거나 오류를 처리하는 등의 작업을 수행합니다.

예를 들어, Node.js의 `fs` 모듈을 사용하여 파일을 읽는 비동기 함수인 `fs.readFile()`은 다음과 같이 콜백 패턴을 사용합니다

```js
const fs = require('fs');

fs.readFile('file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
  } else {
    console.log(data);
  }
});
```

위 예제에서 `fs.readFile()` 함수는 파일을 비동기적으로 읽고, 작업이 완료되면 콜백 함수를 호출합니다. 콜백 함수는 `err`과 `data` 두 개의 인자를 받는데, `err`은 오류 객체이며, `data`는 파일의 내용을 담고 있습니다. 이를 통해 파일 읽기 작업의 성공 여부를 확인하고, 파일 내용을 출력하거나 오류를 처리할 수 있습니다.

콜백 패턴은 비동기 작업을 처리하는 일반적인 방법 중 하나이지만, 콜백 헬(callback hell)이라는 코드가 중첩되어 복잡해지는 단점이 있습니다. 이를 해결하기 위해 Promise, async/await 등의 다양한 비동기 처리 방법이 도입되었습니다.


## Callback Rules
1. 콜백은 마지막 인자로 전달됩니다: 일반적으로 콜백은 함수의 마지막 인자로 전달되어야 합니다. 이는 관례적으로 사용되며, 에러 처리 등의 예외 상황을 콜백에서 처리할 수 있도록 합니다.

2. 콜백은 에러 우선(error-first) 패턴을 따릅니다: 콜백은 첫 번째 인자로 에러를 전달하는 에러 우선 패턴을 따릅니다. 콜백이 호출될 때 에러가 발생하면 첫 번째 인자로 에러 객체가 전달되고, 에러가 없으면 첫 번째 인자는 null 또는 undefined로 전달됩니다.

3. 오류 전파
	3-1.  오류 우선 콜백(Error-First Callback) 패턴: Node.js에서 일반적으로 사용되는 콜백 패턴으로, 콜백 함수의 첫 번째 매개변수를 오류 객체(Error Object)로 사용하는 것입니다. 오류가 발생하지 않으면 이 매개변수는 null 또는 undefined로 설정됩니다. 오류가 발생하면 이 매개변수를 통해 오류 정보를 전달하고, 호출자가 이를 확인하여 오류를 처리할 수 있습니다. 예를 들어, 다음과 같이 오류 우선 콜백 패턴을 사용할 수 있습니다.
	
```js
fs.readFile('file.txt', 'utf8', function(err, data) {
  if (err) {
    console.error('파일을 읽는 중 오류 발생:', err);
  } else {
    console.log('파일 내용:', data);
  }
});
```
3-2. 예외 처리: Node.js에서는 예외(Exception)을 처리하기 위해 try-catch 블록을 사용할 수 있습니다. 예외가 발생하면 해당 블록 내에서 예외를 캐치하고 처리할 수 있습니다. 예를 들어, 다음과 같이 try-catch 블록을 사용하여 예외를 처리할 수 있습니다:
```js
try {
  // 예외가 발생할 수 있는 코드
} catch (err) {
  console.error('오류 발생:', err);
}
```
<br />
4. 캐치되지 않는 예외

#### 에러(Exception): 처리하지 못한 에러
- 노드 스레드를 멈춤
- 노드는 기본적으로 싱글 스레드라 스레드가 멈춘다는 것은 프로세스가 멈춘는 것
- 에러 처리는 필수!

#### 기본적으로 try catch문으로 예외를 처리

- 에러가 발생할 만한 곳을 try catch로 감싼다

####  예측 불가능한 에러를 처리하는 동작(uncaughtException)
```js
process.on('uncaughtException', (err) => {
	console.log('예기치 못한 에러', err);
	process.exit(1) // 종료 코드1과 함께 App 종료
});
 
setInterval(() => {
	throw new Error('새로운 에러');
}, 1000);
 
setTimeout(() => {
	console.log('실행됩니다');
}, 2000);
```
#### uncaughtException 이벤트를 통한 에러 처리

- 콜백 함수의 동작이 보장되지 않음
- 따라서 복구 작업용으로 쓰는 것은 부적합
- 에러 내용 기록 용으로만 쓰는게 좋음

**제일 좋은 방법은 에러를 확인하고, 프로세스를 종료한 후 서버를 재시작 하는 것이다**








<br />

# Node.JS Observer Pattern

Node.js에서 관찰자(Observer) 패턴은 이벤트 기반(event-driven) 아키텍처를 구현하는데 많이 사용되는 패턴 중 하나입니다. 관찰자 패턴은 한 객체(주체, Subject)가 상태가 변경될 때 다른 객체(관찰자, Observer)들에게 이를 통지하고, 관찰자들은 자동으로 업데이트되는 패턴입니다. 이를 통해 객체 간의 느슨한 결합(loose coupling)을 유지하며, 이벤트 기반 시스템에서 비동기적으로 상호작용할 수 있습니다.

Node.js에서의 관찰자 패턴은 주로 이벤트(Events) 모듈을 통해 구현됩니다. Events 모듈은 Node.js의 내장 모듈로, 이벤트를 생성하고, 리스너를 등록하고, 이벤트를 발생시키는 기능을 제공합니다. 관찰자 패턴을 사용하여 이벤트를 통지하고 관찰자들이 이를 처리하는 방식은 다음과 같습니다.

1.  이벤트 생성: 주체 객체는 이벤트를 생성합니다. 예를 들어, `events` 모듈의 `EventEmitter` 클래스를 사용하여 이벤트를 생성할 수 있습니다.

```js
const EventEmitter = require('events');
const myEmitter = new EventEmitter();
```

2.  리스너 등록: 관찰자 객체들은 주체 객체의 이벤트에 대한 리스너를 등록합니다. 이 리스너는 이벤트가 발생했을 때 실행될 콜백 함수를 정의합니다.

```js
myEmitter.on('event', (arg1, arg2) => {
  // 이벤트 발생 시 실행될 동작
});
```

3.  이벤트 발생: 주체 객체는 이벤트를 발생시킵니다. 이벤트가 발생하면 등록된 모든 리스너들의 콜백 함수가 실행됩니다.

```js
myEmitter.emit('event', arg1, arg2); // 이벤트 발생
```

위와 같이 이벤트를 생성, 리스너를 등록하고 이벤트를 발생시킴으로써 관찰자 패턴을 구현할 수 있습니다. 이를 통해 다양한 컴포넌트들 간의 상호작용을 이벤트 기반으로 처리할 수 있습니다. 예를 들어, HTTP 요청이나 파일 시스템의 변경 등의 이벤트를 처리하기 위해 관찰자 패턴을 사용할 수 있습니다.


4. 예외 처리
4-1.  이벤트 리스너 내부 예외 처리: 이벤트 리스너 함수 내부에서 예외가 발생하는 경우, 해당 예외를 적절히 처리해야 합니다. 예를 들어, try-catch 블록을 사용하여 예외를 캐치하고, 적절한 예외 처리 로직을 수행할 수 있습니다. 예를 들어, 에러 이벤트를 발생시켜 관찰자에게 알릴 수 있습니다.
```js
eventEmitter.on('someEvent', (data) => {
  try {
    // 이벤트 처리 로직
  } catch (err) {
    console.error('예외 발생:', err);
    // 에러 이벤트 발생시키기
    eventEmitter.emit('errorEvent', err);
  }
});
```
4-2.  'error' 이벤트 사용: Node.js에서는 'error' 이벤트가 내장되어 있어, 이를 활용하여 예외를 처리할 수 있습니다. 'error' 이벤트는 이벤트 리스너에서 예외가 발생하면 자동으로 호출되며, uncaughtException과 같은 예외가 발생하는 것을 방지할 수 있습니다.

```js
eventEmitter.on('error', (err) => {
  console.error('예외 발생:', err);
});
```

4-3. uncaughtException 이벤트 사용: Node.js에서는 uncaughtException 이벤트를 사용하여 예외를 처리할 수 있습니다. 이 이벤트는 예외가 처리되지 않은 경우에 호출됩니다. 하지만 이 이벤트는 마지막 수단으로 사용되어야 하며, 서버를 안정적으로 유지하기 위해 사용되어서는 안 됩니다.

```js
process.on('uncaughtException', (err) => {
  console.error('예외 발생:', err);
  // 예외 처리 로직
});
```

<br />

### 관찰자 패턴과 콜백 패턴의 선택 기준

관찰자 패턴과 콜백 패턴 중 어떤 것을 선택할지는 다양한 요소에 따라 달라질 수 있습니다. 일반적으로 다음과 같은 기준들이 고려될 수 있습니다:

1.  이벤트 처리의 복잡성: 관찰자 패턴은 이벤트 기반의 비동기 처리를 다루는데 적합하며, 여러 개의 이벤트가 발생하거나 이벤트 간의 관계가 복잡할 때 사용될 수 있습니다. 반면에, 콜백 패턴은 비교적 단순한 비동기 처리에 적합하며, 단일 콜백 함수를 통해 결과를 처리하는 경우에 주로 사용될 수 있습니다.
    
2.  확장성과 유연성: 관찰자 패턴은 여러 개의 관찰자를 등록하여 이벤트 처리를 확장할 수 있습니다. 이에 반해, 콜백 패턴은 콜백 함수의 중첩이 발생하여 코드가 복잡해지고 유지보수가 어려울 수 있습니다. 관찰자 패턴은 이벤트의 발생과 처리를 느슨하게 결합하여 유연성이 높고 확장성이 좋은 반면, 콜백 패턴은 비교적 간단한 경우에 적합할 수 있습니다.
    
3.  코드 가독성과 유지보수성: 최근에는 프로미스(Promise)와 async/await와 같은 비동기 처리를 위한 더 나은 대안들이 등장하여, 콜백 헬(Callback Hell) 문제를 해결할 수 있습니다. 관찰자 패턴은 비동기 이벤트를 처리하는데 있어서 코드의 가독성과 유지보수성을 높일 수 있습니다.
    
4.  기존 코드와의 호환성: 기존에 작성된 코드나 라이브러리에서 이미 관찰자 패턴이 사용되고 있다면, 해당 패턴을 따라가는 것이 일관성을 유지하고 호환성을 확보할 수 있습니다. 마찬가지로, 기존에 작성된 코드나 라이브러리에서 이미 콜백 패턴이 사용되고 있다면, 해당 패턴을 따라가는 것이 일관성을 유지하고 호환성을 확보할 수 있습니다.
    

상황에 따라 관찰자 패턴과 콜백 패턴 중에서 선택하는 것이 좋을 수 있습니다. 개발자는 코드의 복잡성, 확장성, 유연성, 가독성, 유지보수성, 기존 코드와의 호환성 등을 고려하여 패
