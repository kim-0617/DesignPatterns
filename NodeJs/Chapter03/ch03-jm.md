## 콜백은 이전 장에서 소개한 리액터 패턴의 핸들러를 구현한 것입니다. (92p)
### 리액터 패턴의 핸들러가 뭔데요? (1장 복습)
![리액터 패턴](https://velog.velcdn.com/images/qjqdn1568/post/8c815e10-1a60-42a4-9764-4d1ecf18c6fa/image.png)
> 여기서 4번입니다.
- 그림에서는 이벤트 루프를 통해 이벤트를 수신하고, 이벤트를 처리하기 위한 콜백 함수를 등록하고 호출하는 과정을 보여줍니다.
- 이벤트 루프를 실행하는 것은 Reactor이며, 콜백 함수는 EventHandler에 해당합니다.
- 즉, 이벤트 루프와 EventHandler 사이에는 콜백 함수가 위치하고, 콜백 함수는 EventHandler를 통해 이벤트 루프와 통신하게 됩니다.
***
### 콜백은 리액터 패턴의 핸들러를 구현한 것
Reactor pattern은 이벤트 주도 아키텍처 디자인 패턴으로, 일반적으로 하나 이상의 입력 소스(파일, 소켓, 시그널 등)에서 발생한 이벤트를 비동기식으로 처리하는 방법입니다.

Node.js에서의 콜백(callback)은 이벤트 주도 아키텍처에서 주요 구성 요소 중 하나입니다. 콜백은 보통 비동기식으로 처리되는 작업이 완료되었을 때 실행되는 함수입니다. 예를 들어, 파일 읽기 작업이 완료되면 콜백 함수가 호출되어 파일 데이터를 처리하고 다음 작업을 계속할 수 있습니다.

Node.js에서는 이벤트 루프(Event Loop)가 이벤트 소스에서 발생한 이벤트를 감지하고 이벤트 핸들러를 호출합니다. 이벤트 핸들러는 콜백 함수를 호출하고, 콜백 함수는 비동기식으로 처리되는 작업을 완료하고 결과를 반환합니다. 이 결과를 다시 이벤트 루프가 받아서 다음 작업을 처리하는 방식으로 동작합니다.

따라서 Node.js에서 콜백은 이벤트 핸들러를 처리하는데 사용되는 메커니즘이며, 비동기식 프로그래밍에서 매우 중요한 역할을 합니다.


## 클로저 덕분에 콜백이 다른 시점과 ... 비동기 함수의 호출자 컨텍스트를 유지하기 때문입니다. (95p)
JavaScript에서 비동기 함수가 호출되면, 해당 함수는 이벤트 루프에 의해 비동기적으로 처리됩니다. 이때 함수는 일반적으로 콜백 함수를 통해 결과를 반환하게 됩니다.

이벤트 루프는 콜백 함수가 비동기 함수 호출과 동일한 컨텍스트에서 실행되도록 보장합니다. 이러한 컨텍스트는 클로저로써 유지됩니다. 이는 콜백 함수가 비동기 함수 호출 이후에도 여전히 해당 함수의 변수와 범위를 액세스할 수 있다는 것을 의미합니다. 따라서 클로저를 사용하여 콜백 함수가 원하는 작업을 수행하고, 동시에 비동기 함수 호출의 호출자 컨텍스트를 유지할 수 있습니다.
***
### 호출자 컨텍스트 with 클로저, 콜백 함수
호출자 컨텍스트는 함수가 호출된 위치에서의 환경 정보를 말합니다. 즉, 함수가 어디에서 호출되었는지에 따라서 그 함수가 참조하는 변수, 상수, 객체 등의 값이 달라질 수 있습니다.

예를 들어, 함수 A 내부에서 함수 B를 호출하면, 함수 B는 함수 A 내부에서 호출된 것으로 인식됩니다. 따라서 함수 B는 함수 A에서 선언한 변수나 객체 등에 접근할 수 있습니다. 이때 함수 B가 비동기 함수이고, 콜백 함수로 전달될 경우, 함수 B의 실행이 완료되어 콜백 함수가 호출될 때에도 함수 A에서 선언한 변수나 객체 등에 접근할 수 있습니다. 이는 클로저(closure) 개념과 밀접한 관련이 있습니다. 클로저란, 함수가 선언될 당시의 환경 정보를 유지하고 있다가, 함수가 호출될 때 그 정보를 참조하는 것을 말합니다.

이와 같은 이유로, 자바스크립트에서 비동기 처리를 위해 콜백 함수를 사용할 때, 클로저를 이용하여 호출자 컨텍스트를 유지할 수 있습니다. 이를 통해, 콜백 함수가 다른 시점이나 위치에서 호출되더라도, 호출되었을 때의 환경 정보를 그대로 사용할 수 있습니다.


## process.nextTick()으로 지연된 콜백은 마이크로태스크라 ... 다른 I/O 이벤트가 발생하기 전에 실행됩니다. (101p)
마이크로태스크는 자바스크립트 엔진의 이벤트 루프(Event Loop)에서 실행되는 작은 태스크입니다. 이벤트 루프는 크게 마이크로태스크 큐와 매크로태스크 큐로 나뉘며, 마이크로태스크 큐에는 콜백 함수들이 저장되어 있습니다.

마이크로태스크는 매크로태스크보다 우선순위가 높으며, 현재 실행 중인 태스크가 종료된 후 바로 실행됩니다. 따라서, process.nextTick()으로 지연된 콜백 함수들은 다른 I/O 이벤트가 발생하기 전에 우선적으로 실행됩니다.

이러한 특성을 이용하면, 비동기적인 코드에서 콜백 함수를 처리하는 시점을 더 세밀하게 조절할 수 있습니다. 예를 들어, 프로미스에서 resolve() 함수나 then() 메서드 내에서 호출된 콜백 함수들은 마이크로태스크 큐에 저장되어 다른 I/O 이벤트가 발생하기 전에 우선적으로 처리됩니다.
***
### process.nextTick()은 이미 예정된 I/O보다 먼저 ... I/O기아(starvation)를 발생시킬 수 있습니다.
process.nextTick()은 현재 작업이 완료된 후 바로 실행되는 마이크로태스크 함수입니다. 따라서, process.nextTick()으로 등록된 콜백 함수가 매우 많거나 무한정 호출되는 상황에서는 다른 I/O 이벤트를 처리하는데 필요한 시간보다 더 많은 시간을 소비하게 됩니다. 이 경우, 이벤트 루프는 process.nextTick()으로 등록된 콜백 함수들을 처리하기 위해 다른 I/O 이벤트를 처리하지 못하게 되어 `I/O 기아`가 발생하게 됩니다. 이는 시스템의 전반적인 성능에 영향을 미칠 수 있으므로 주의가 필요합니다.


## ... 3가지의 이벤트를 발생시키는 EventEmitter 인스턴스를 반환합니다. (109p)
### Node.js에서 이벤트가 뭔데요?
Node.js에서 Event는 EventEmitter 클래스의 인스턴스를 통해 다룰 수 있는 일종의 신호(signal)입니다.

EventEmitter 클래스는 Node.js에서 이벤트 기반(event-driven) 프로그래밍을 위한 핵심 클래스 중 하나로, 다양한 이벤트를 발생시키고 이벤트를 구독하는 메서드를 제공합니다.

예를 들어, 파일을 읽기 시작할 때와 같이 어떤 동작이 시작되면, EventEmitter 인스턴스는 이벤트를 발생시킵니다. 이 때, 이벤트 이름과 함께 전달되는 데이터는 해당 이벤트를 구독하는 콜백 함수에서 사용됩니다.

EventEmitter 인스턴스는 이벤트를 등록하고 삭제할 수 있으며, 이벤트가 발생할 때마다 등록된 콜백 함수를 실행시킵니다. 이를 통해 비동기적으로 발생하는 이벤트를 처리하고, 이벤트에 응답하는 코드를 작성할 수 있습니다.

간단하게 말하면, EventEmitter는 어떤 이벤트가 발생하면 등록된 함수를 실행시켜주는 역할을 합니다. 이를 통해 비동기적으로 발생하는 이벤트에 대한 처리를 가능하게 하고, 이벤트에 응답하는 코드를 간단하게 작성할 수 있게 됩니다.


## 핵심 HTTP 모듈의 Server 객체의 EventEmitter 함수 상속은 request... (111p)
Node.js의 HTTP 모듈의 Server 객체는 EventEmitter를 상속하며 다양한 이벤트를 발생시킬 수 있습니다.

주요한 이벤트는 다음과 같습니다.
[Node.js docs class-httpserver](https://nodejs.org/api/http.html#event-checkcontinue)

- request: 새로운 HTTP 요청이 도착했을 때 발생합니다. 요청과 응답 객체가 매개변수로 전달됩니다.
- connection: 새로운 TCP 연결이 생성될 때 발생합니다.
- close: 서버가 종료될 때 발생합니다.
- checkContinue: 클라이언트가 100 Continue 응답을 보냈을 때 발생합니다.
- upgrade: 클라이언트가 HTTP 업그레이드 요청을 보냈을 때 발생합니다.
- clientError: 클라이언트가 에러를 발생시켰을 때 발생합니다.

이 외에도 많은 이벤트들이 존재합니다. 개발자는 필요한 이벤트를 정의하여 사용할 수도 있습니다.