# 02

## 2-4 CommonJS 모듈

- 첫번째 내장 모듈 시스템
- require와 module.export, export 를 통해 모듈 관리
- module.exports와 exports 키워드는 사실상 같다. 같은 객체를 참조한다. exports 키워드가 module.exports가 가리키는 객체를 똑같이 바라본다.
- 사실상 말하고 싶은것은 exports 부분에 포함된것만 모듈내에서 공개된 것들이고, 나머지는 다 비밀로 유지할 수 있다.
- require함수는 동기적이기 때문에 비동기적으로 호출하는 것은 옳지 않다. 또한 조건문에 분기를 태워서 조건에 따라 다른 모듈을 require할 수 도 있다.
- 또한 require로 한번 부른 모듈은 캐싱된다.

### 2-4-7 순환종속성

- main 에서 a모듈을 불렀습니다.
- a모듈은 b모듈을 부릅니다.
- b모듈은  a모듈을 부릅니다.
- a모듈을 부르면 또 b 모듈을 부릅니다.
- 처음에는 이렇게 되서 무한대로 꼬리가 물리는게 아닌가 싶었습니다.
- 근데 캐싱이되니까 그렇지 않고 한번불러놓으면 계속부르는 과정에서 캐싱된 데이터를 사용하지 않을까 확신하고 있습니다.
- 그런데 캐싱을 한다고 해도 무한대로 꼬리를 물고있다는 소리아닙니까? ㄷㄷ;

### 2-5-3 인스턴스 내보내기

```java
class Logger {
  constructor (name) {
    this.count = 0
    this.name = name
  }

  log (message) {
    this.count++
    console.log('[' + this.name + '] ' + message)
  }
}

module.exports = new Logger('DEFAULT')
```

- 오우 ⇒ 싱글턴 패턴과 비슷하게 동작하네요
- 그런데 클래스이름.constructor로 생성할 수 있네요 ⇒ 약점

### 2-6 ESM 모듈

- 임포트가 모든모듈의 가장 상위레벨과 제어흐름구문의 바깥쪽에 기술됩니다.
- 또한, 임포트할 모듈의 이름을 코드를 이용하여 실행시에동적으로생성할수없으며,  상수문자열만이 허용됩니다.

### 2-6-7 ESM 모듈의 순환종속성

- CommonJs와 마찬가지로 main ⇒ a ⇒ b 순서로 호출된다고 했을 때,
- main → a 탐색 후 b로가는 import 경로를 발견해서 b로 갑니다.
- b에서 다시 a로가는 순환종속성의 코드를 발견했으나 한번 갔다왔으니 가지 않습니다.
- 따라서 main → a → b의 트리구조의 형태가 만들어지고, 순환종속성이 없어집니다.

- main ⇒ a import 문을 발견하고 a 로 갑니다.
- a ⇒ b import 문을 발견하고 b 로 갑니다.
- b ⇒ a import 문을 발견하고 a로 가려했으나 이미 갔기때문에 가지않고 main으로 돌아갑니다. (b가 다른 import 문을 갖고있지 않기 때문에)
- main ⇒ b 로가는 import 문을 발견하고 b로 가려했으나 이미가서 무시합니다.
- 이제 이 main ⇒ a ⇒ b 의 트리구조를 밑에서부터, 즉 b 부터 시작해서 export 맵을 만듭니다.
- b부터 시작해서 a ⇒ main 순으로 무엇을 export 시키고 있나 지도를 만듭니다.
- 지도를 만들었으면 마찬가지로 b부터 시작해서 올라가면서 export 된 값들을 평가하면서 올라갑니다.
- 끝

## 핵심 내용

1. CommonJS는 require 될 때 module.exports 객체를 얕은 복사한다. 따라서 불변성이 지켜지지 않는다.
2. 반면에 ESM 모듈 임포트 방식은 파일을 읽어들일때, 모든 import문을 재귀적으로 탐색하면서 종속성 트리를 만들고 값들을 모두 읽기 전용으로 만들어버린다.
3. 따라서 import 한 값을 변경하려고 해도 마치 const에 할당된 변수를 재할당 할 때 처럼 오류가 나버리게 된다.